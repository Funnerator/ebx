#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'

require 'ebx'

program :version, '0.0.1'
program :description, 'eb eXtended'

DEFAULT_ENV = ['production', 'development', 'staging', 'test']
 
command :init do |c|
  c.syntax = 'ebx init [options]'
  c.summary = 'Init a new project'
 # c.description = 'test'
 # c.example 'description', 'command example'
 # c.option '--some-switch', 'Some switch that does something'
  #
  #
  ##
  #      queue.add(TryLoadEbConfigFileOperation(queue))
  #      queue.add(ReadAwsCredentialFileOperation(queue))
  #      queue.add(AskForConfigFileParameterOperation(queue))
  #      queue.add(ValidateParameterOperation(queue))
  #      queue.add(RotateOptionsettingFileOperation(queue))
  #      queue.add(SanitizeBranchOperation(queue))
  #      queue.add(UpdateAwsCredentialFileOperation(queue))
  #      queue.add(SanitizeAppVersionNameOperation(queue))
  #      queue.add(SaveEbConfigFileOperation(queue))
  #      queue.add(UpdateDevToolsConfigOperation(queue))
  #      queue.add(CheckGitIgnoreFileOperation(queue))
  # 
  c.action do |args, options|
    DEFAULT_ENV.each do |env|
      ENV['AWS_ENV'] = env
      Ebx::AwsEnvironmentConfig.init_config
    end
  end
end


command :info do |c|
  c.syntax = 'ebx info [env] [options]'
  c.summary = 'show project settings'
  c.option '--verbose', 'Show option settings'

  c.action do |args, options|
    config = Ebx::AwsEnvironmentConfig.read_config
    env_name = (args.shift || 'development')
    env = config[env_name]

    puts "  ====[#{env_name}]===="
    puts "        Name: #{env['name']}"
    puts " Description: #{env['description']}"
    puts "      App ID: #{env['app_id']}"
    puts "       Stack: #{env['solution_stack']}"
    puts "     Regions: #{env['environments'].collect{|e| e['region']} }"
    puts ""

    if options.verbose
      env['option_settings'].each do |ns, val|
        puts "[#{ns}]"
        val.each do |k,v|
          puts "  #{k} : #{v}"
        end
        puts ""
      end
    end
  end
end


#    elif command == CommandType.START:
#        queue.add(CheckGitIgnoreFileOperation(queue))
#        queue.add(LoadEbConfigFileOperation(queue))
#        queue.add(ReadAwsCredentialFileOperation(queue))
#        queue.add(TryGetCurrentBranchOperation(queue))
#        queue.add(AskForMissiongParameterOperation(queue))
#        queue.add(ValidateParameterOperation(queue))
#        queue.add(CreateApplicationOperation(queue))
#        queue.add(CreateApplicationVersionOperation(queue))
#        queue.add(CreateEnvironmentOperation(queue))
#        queue.add(SleepOperation(queue))
#        queue.add(SaveConfigurationSettingOperation(queue))
#        queue.add(WaitForCreateEnvironmentFinishOperation(queue))


command :start do |c|
  c.syntax = 'ebx start [env] [options]'
  c.summary = 'Create an environment'

  c.action do |args, options|
    ENV['AWS_ENV'] ||= (args.shift || 'development')

    Ebx::AwsCredentialConfig.set_credentials
    Ebx::DeployGroup.new.create
  end
end

command :stop do |c|
  c.syntax = 'ebx stop [env] [options]'
  c.summary = 'Stop a running environment'

  c.action do |args, options|
    ENV['AWS_ENV'] ||= (args.shift || 'development')

    Ebx::AwsCredentialConfig.set_credentials
    Ebx::DeployGroup.new.stop
  end
end

command :log do |c|
  c.syntax = 'ebx log [env] [options]'
  c.summary = 'Retrieve logs cross region'
  c.action do |args, options|
    ENV['AWS_ENV'] ||= (args.shift || 'development')

    Ebx::AwsCredentialConfig.set_credentials
    Ebx::DeployGroup.new.logs
  end
end

command :status do |c|
  c.action do |args, options|
    ENV['AWS_ENV'] ||= (args.shift || 'development')
    Ebx::AwsCredentialConfig.set_credentials

    Ebx::DeployGroup.new.describe
  end
end


command :shell do |c|
  c.syntax = 'ebx shell [env]'
  c.summary = 'ssh to one of the ec2 machines in [env]'

  c.action do |args, options|
    ENV['AWS_ENV'] ||= (args.shift || 'development')
    ec2_id = Ebx::DeployGroup.new.ec2_instance_ids.first
    dns_name = AWS::ec2.instances[ec2_id].dns_name
    puts "ssh ec2-user@#{dns_name}\n"

    system "ssh ec2-user@#{dns_name}"
  end
end
